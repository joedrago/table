// Generated by CoffeeScript 2.5.1
(function() {
  var ShuffledDeck, Table;

  ShuffledDeck = class ShuffledDeck {
    constructor() {
      var i, j, k;
      // dat inside-out shuffle!
      this.cards = [0];
      for (i = k = 1; k < 52; i = ++k) {
        j = Math.floor(Math.random() * i);
        this.cards.push(this.cards[j]);
        this.cards[j] = i;
      }
    }

  };

  Table = class Table {
    constructor(id) {
      this.id = id;
      this.nextAnonymousID = 1;
      this.name = "Generic Table";
      this.resetAge();
      this.players = {};
      this.owner = null;
      this.deck = new ShuffledDeck();
      this.pile = [];
    }

    log(text) {
      var pid, player, ref, results;
      ref = this.players;
      results = [];
      for (pid in ref) {
        player = ref[pid];
        if (player.socket !== null) {
          results.push(player.socket.emit('chat', {
            text: text
          }));
        } else {
          results.push(void 0);
        }
      }
      return results;
    }

    resetAge() {
      return this.age = new Date();
    }

    anonymousName() {
      var name;
      name = `Anonymous ${this.nextAnonymousID}`;
      this.nextAnonymousID += 1;
      return name;
    }

    playerConnect(pid, socket) {
      console.log(`Connect: ${pid}`);
      if (this.players[pid] == null) {
        this.players[pid] = {
          id: pid,
          socket: null,
          name: this.anonymousName(),
          score: 0,
          bid: 0,
          playing: false,
          hand: []
        };
      }
      this.players[pid].socket = socket;
      if (this.owner === null) {
        this.owner = pid;
      }
      return this.broadcast();
    }

    playerDisconnect(pid) {
      var player, ref;
      console.log(`Disconnect: ${pid}`);
      if (this.players[pid] != null) {
        this.players[pid].socket = null;
      }
      if (pid === this.owner) {
        ref = this.players;
        for (pid in ref) {
          player = ref[pid];
          if (player.socket !== null) {
            this.owner = pid;
            break;
          }
        }
      }
      return this.broadcast();
    }

    deal(template) {
      var j, k, pid, player, playingCount, ref, ref1;
      switch (template) {
        case 'all13':
          this.pile = [];
          this.deck = new ShuffledDeck();
          playingCount = 0;
          ref = this.players;
          for (pid in ref) {
            player = ref[pid];
            if (player.playing) {
              playingCount += 1;
            }
          }
          if (playingCount > 4) {
            this.log(`ERROR: Too many players (${playingCount}) to deal 13 to everyone.`);
            return;
          }
          ref1 = this.players;
          for (pid in ref1) {
            player = ref1[pid];
            if (player.playing) {
              player.hand = [];
              for (j = k = 0; k < 13; j = ++k) {
                player.hand.push(this.deck.cards.shift());
              }
            }
          }
          return this.broadcast();
      }
    }

    msg(msg) {
      var chat, found, k, l, len, len1, len2, len3, len4, m, n, newHand, o, pid, pileX, pileY, player, raw, rawSelected, rawSelectedIndex, ref, ref1, ref2, ref3, ref4, ref5, ref6, ref7;
      switch (msg.type) {
        case 'renamePlayer':
          if ((msg.name != null) && (this.players[msg.pid] != null)) {
            this.log(`'${this.players[msg.pid].name}' is now '${msg.name}'.`);
            this.players[msg.pid].name = msg.name;
            this.broadcast();
          }
          break;
        case 'renameTable':
          if ((this.players[msg.pid] != null) && (msg.pid === this.owner) && (msg.name != null)) {
            this.log(`The table is now named '${msg.name}'.`);
            this.name = msg.name;
            this.broadcast();
          }
          break;
        case 'changeOwner':
          if ((this.players[msg.pid] != null) && (msg.pid === this.owner) && (msg.owner != null)) {
            if ((this.players[msg.owner] != null) && (this.players[msg.owner].socket !== null)) {
              this.owner = msg.owner;
            }
            this.broadcast();
          }
          break;
        case 'setScore':
          if ((this.players[msg.pid] != null) && (msg.pid === this.owner) && (msg.scorepid != null) && (msg.score != null)) {
            if (this.players[msg.scorepid] != null) {
              this.players[msg.scorepid].score = msg.score;
              this.broadcast();
            }
          }
          break;
        case 'setBid':
          if ((this.players[msg.pid] != null) && (msg.pid === this.owner) && (msg.bidpid != null) && (msg.bid != null)) {
            if (this.players[msg.bidpid] != null) {
              this.players[msg.bidpid].bid = msg.bid;
              this.broadcast();
            }
          }
          break;
        case 'togglePlaying':
          if ((this.players[msg.pid] != null) && (msg.pid === this.owner) && (msg.togglepid != null)) {
            if (this.players[msg.togglepid] != null) {
              this.players[msg.togglepid].playing = !this.players[msg.togglepid].playing;
              this.broadcast();
            }
          }
          break;
        case 'resetScores':
          if ((this.players[msg.pid] != null) && (msg.pid === this.owner)) {
            ref = this.players;
            for (pid in ref) {
              player = ref[pid];
              player.score = 0;
            }
            this.broadcast();
            this.log("Scores reset.");
          }
          break;
        case 'resetBids':
          if ((this.players[msg.pid] != null) && (msg.pid === this.owner)) {
            ref1 = this.players;
            for (pid in ref1) {
              player = ref1[pid];
              player.bid = 0;
            }
            this.broadcast();
            this.log("Bids reset.");
          }
          break;
        case 'chat':
          if (this.players[msg.pid] != null) {
            chat = {
              pid: msg.pid,
              text: msg.text
            };
            ref2 = this.players;
            for (pid in ref2) {
              player = ref2[pid];
              if (player.socket !== null) {
                player.socket.emit('chat', chat);
              }
            }
          }
          break;
        case 'deal':
          if ((this.players[msg.pid] != null) && (msg.pid === this.owner) && (msg.template != null)) {
            this.deal(msg.template);
          }
          break;
        case 'throwSelected':
          if ((this.players[msg.pid] != null) && (msg.selected != null) && (msg.selected.length > 0)) {
            player = this.players[msg.pid];
            ref3 = msg.selected;
            // make sure all selected cards exist in the player's hand
            for (k = 0, len = ref3.length; k < len; k++) {
              rawSelected = ref3[k];
              found = false;
              ref4 = player.hand;
              for (l = 0, len1 = ref4.length; l < len1; l++) {
                raw = ref4[l];
                if (raw === rawSelected) {
                  found = true;
                  break;
                }
              }
              if (!found) {
                this.log("ERROR: You can't throw what you dont have.");
                return;
              }
            }
            // build a new hand with the selected cards absent
            newHand = [];
            ref5 = player.hand;
            for (m = 0, len2 = ref5.length; m < len2; m++) {
              raw = ref5[m];
              found = false;
              ref6 = msg.selected;
              for (n = 0, len3 = ref6.length; n < len3; n++) {
                rawSelected = ref6[n];
                if (raw === rawSelected) {
                  found = true;
                }
              }
              if (!found) {
                newHand.push(raw);
              }
            }
            player.hand = newHand;
            // Add to the pile
            pileX = Math.floor(Math.random() * 100);
            pileY = Math.floor(Math.random() * 80);
            ref7 = msg.selected;
            for (rawSelectedIndex = o = 0, len4 = ref7.length; o < len4; rawSelectedIndex = ++o) {
              rawSelected = ref7[rawSelectedIndex];
              this.pile.push({
                raw: rawSelected,
                x: pileX + (rawSelectedIndex * 20),
                y: pileY
              });
            }
            this.log(`${player.name} throws ${msg.selected.length} card${msg.selected.length === 1 ? "" : "s"}.`);
            this.broadcast();
          }
      }
    }

    broadcast() {
      var pid, player, players, ref, ref1, state;
      players = [];
      ref = this.players;
      for (pid in ref) {
        player = ref[pid];
        if (player.socket !== null) {
          players.push({
            pid: pid,
            name: player.name,
            score: player.score,
            bid: player.bid,
            playing: player.playing,
            count: player.hand.length
          });
        }
      }
      state = {
        name: this.name,
        owner: this.owner,
        players: players,
        pile: this.pile
      };
      ref1 = this.players;
      for (pid in ref1) {
        player = ref1[pid];
        if (player.socket !== null) {
          state.hand = player.hand;
          player.socket.emit('state', state);
        }
      }
    }

  };

  module.exports = Table;

}).call(this);
